<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<title>virtual function specifier - cppreference.com</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">
<link rel="shortcut icon" href="../../../common/favicon.ico">
<link rel="stylesheet" href="../../../common/ext.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="../../../common/site_modules.css">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:7:472787eddcf4605d11de8c7ef047234f */</style>

<script src="../../../common/startup_scripts.js"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"cpp/language/virtual","wgTitle":"cpp/language/virtual","wgCurRevisionId":139982,"wgArticleId":4061,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"cpp/language/virtual","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":0,"showtoolbar":1,"skin":"cppreference2","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"gadget-ColiruCompiler":1,"gadget-MathJax":1});;},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});;},{},{});
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-js:7:9f05c6caceb9bb1a482b6cebd4c5a330 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_language_virtual skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        <!-- /header -->
        <!-- content -->
<div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
<h1 id="firstHeading" class="firstHeading"><code>virtual</code> function specifier</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">From cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../cpp.html" title="cpp">cpp</a>‎ | <a href="../language.html" title="cpp/language">language</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="t-navbar" style=""><div class="t-navbar-sep"> </div><div class="t-navbar-head"><a href="../../cpp.html" title="cpp"> C++</a><div class="t-navbar-menu"><div><div><table class="t-nv-begin" cellpadding="0" style="line-height:1.1em;">
<tr class="t-nv"><td colspan="5"> <a href="../compiler_support.html" title="cpp/compiler support"> Compiler support</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../freestanding.html" title="cpp/freestanding"> Freestanding and hosted</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../language.html" title="cpp/language"> Language</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../standard_library.html" title="cpp/standard library"> Standard library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../headers.html" title="cpp/header"> Standard library headers</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../named_req.html" title="cpp/named req"> Named requirements </a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../feature_test.html" title="cpp/feature test"> Feature test macros </a> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../utility.html#Language_support" title="cpp/utility"> Language support library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../concepts.html" title="cpp/concepts"> Concepts library</a> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../meta.html" title="cpp/meta"> Metaprogramming library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../error.html" title="cpp/error"> Diagnostics library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../utility.html" title="cpp/utility"> General utilities library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../string.html" title="cpp/string"> Strings library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../container.html" title="cpp/container"> Containers library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../iterator.html" title="cpp/iterator"> Iterators library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../ranges.html" title="cpp/ranges"> Ranges library</a> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../algorithm.html" title="cpp/algorithm"> Algorithms library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../numeric.html" title="cpp/numeric"> Numerics library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../locale.html" title="cpp/locale"> Localizations library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../io.html" title="cpp/io"> Input/output library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../filesystem.html" title="cpp/filesystem"> Filesystem library</a> <span class="t-mark-rev t-since-cxx17">(C++17)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../regex.html" title="cpp/regex"> Regular expressions library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../thread.html" title="cpp/thread"> Concurrency support library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../experimental.html" title="cpp/experimental"> Technical specifications</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../symbol_index.html" title="cpp/symbol index"> Symbols index</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../links/libs.html" title="cpp/links/libs"> External libraries</a> </td></tr>
</table></div><div></div></div></div></div><div class="t-navbar-sep"> </div><div class="t-navbar-head"><a href="../language.html" title="cpp/language"> C++ language</a><div class="t-navbar-menu"><div><div style="display:inline-block">
<div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv-h1"><td colspan="5">General topics</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="../preprocessor.html" title="cpp/preprocessor">Preprocessor</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="../comments.html" title="cpp/comment">Comments</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="../keywords.html" title="cpp/keyword">Keywords</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="escape.html" title="cpp/language/escape">Escape sequences</a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"><a href="statements.html" title="cpp/language/statements">Flow control</a></td></tr>
<tr class="t-nv-h2"><td colspan="5">Conditional execution statements</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="if.html" title="cpp/language/if"><tt>if</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="switch.html" title="cpp/language/switch"><tt>switch</tt></a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5">Iteration statements (loops)</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="for.html" title="cpp/language/for"><tt>for</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="range-for.html" title="cpp/language/range-for">range-<code>for</code></a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="while.html" title="cpp/language/while"><tt>while</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="do.html" title="cpp/language/do"><code>do-while</code></a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5">Jump statements</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="continue.html" title="cpp/language/continue"><tt>continue</tt></a> - <a href="break.html" title="cpp/language/break"><tt>break</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="goto.html" title="cpp/language/goto"><tt>goto</tt></a> - <a href="return.html" title="cpp/language/return"><tt>return</tt></a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"><a href="functions.html" title="cpp/language/functions">Functions</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="function.html" title="cpp/language/function">Function declaration</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="lambda.html" title="cpp/language/lambda">Lambda function expression</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="inline.html" title="cpp/language/inline"><code>inline</code> specifier</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="except_spec.html" title="cpp/language/except spec">Dynamic exception specifications</a> <span class="t-mark">(<span title="deprecated in C++11">until C++17*</span>)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="noexcept_spec.html" title="cpp/language/noexcept spec"><code>noexcept</code> specifier</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv-h1"><td colspan="5">Exceptions</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="throw.html" title="cpp/language/throw"><code>throw</code>-expression</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="try_catch.html" title="cpp/language/try catch"><code>try</code>-<code>catch</code> block</a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5">Namespaces</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="namespace.html" title="cpp/language/namespace">Namespace declaration</a>  </td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="namespace_alias.html" title="cpp/language/namespace alias">Namespace aliases</a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5">Types</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="types.html" title="cpp/language/types">Fundamental types</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="enum.html" title="cpp/language/enum">Enumeration types</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="function.html" title="cpp/language/function">Function types</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="class.html" title="cpp/language/class">Class/struct types</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="union.html" title="cpp/language/union">Union types</a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5">Specifiers</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="decltype.html" title="cpp/language/decltype"><tt>decltype</tt></a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="auto.html" title="cpp/language/auto"><tt>auto</tt></a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="alignas.html" title="cpp/language/alignas"><tt>alignas</tt></a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="cv.html" title="cpp/language/cv"><code>const</code>/<code>volatile</code></a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="constexpr.html" title="cpp/language/constexpr"><tt>constexpr</tt></a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
</table></div></td></tr>
<tr class="t-nv"><td colspan="5"><a href="storage_duration.html" title="cpp/language/storage duration">Storage duration specifiers</a></td></tr>
<tr class="t-nv-h2"><td colspan="5"><a href="initialization.html" title="cpp/language/initialization">Initialization</a></td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="default_initialization.html" title="cpp/language/default initialization">Default initialization</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="value_initialization.html" title="cpp/language/value initialization">Value initialization</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="zero_initialization.html" title="cpp/language/zero initialization">Zero initialization</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="copy_initialization.html" title="cpp/language/copy initialization">Copy initialization</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="direct_initialization.html" title="cpp/language/direct initialization">Direct initialization</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="aggregate_initialization.html" title="cpp/language/aggregate initialization">Aggregate initialization</a>    </td></tr>
<tr class="t-nv"><td colspan="5"><a href="list_initialization.html" title="cpp/language/list initialization">List initialization</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="constant_initialization.html" title="cpp/language/constant initialization">Constant initialization</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="reference_initialization.html" title="cpp/language/reference initialization">Reference initialization</a></td></tr>
</table></div></td></tr>
</table></div>
</div>
<div style="display:inline-block">
<div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv-h1"><td colspan="5"><a href="expressions.html" title="cpp/language/expressions">Expressions</a></td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="value_category.html" title="cpp/language/value category">Value categories</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="eval_order.html" title="cpp/language/eval order">Order of evaluation</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="operators.html" title="cpp/language/operators">Operators</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="operator_precedence.html" title="cpp/language/operator precedence">Operator precedence</a></td></tr>
</table></div></td></tr>
<tr class="t-nv"><td colspan="5"><a href="operator_alternative.html" title="cpp/language/operator alternative">Alternative representations</a></td></tr>
<tr class="t-nv-h2"><td colspan="5"><a href="expressions.html#Literals" title="cpp/language/expressions">Literals</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="bool_literal.html" title="cpp/language/bool literal">Boolean</a> - <a href="integer_literal.html" title="cpp/language/integer literal">Integer</a> - <a href="floating_literal.html" title="cpp/language/floating literal">Floating-point</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="character_literal.html" title="cpp/language/character literal">Character</a> - <a href="string_literal.html" title="cpp/language/string literal">String</a> - <a href="nullptr.html" title="cpp/language/nullptr"><tt>nullptr</tt></a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="user_literal.html" title="cpp/language/user literal">User-defined</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv-h1"><td colspan="5">Utilities</td></tr>
<tr class="t-nv"><td colspan="5"><a href="attributes.html" title="cpp/language/attributes">Attributes</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv-h2"><td colspan="5">Types</td></tr>
<tr class="t-nv"><td colspan="5"><a href="typedef.html" title="cpp/language/typedef"><code>typedef</code> declaration</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="type_alias.html" title="cpp/language/type alias">Type alias declaration</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv-h2"><td colspan="5">Casts</td></tr>
<tr class="t-nv"><td colspan="5"><a href="implicit_cast.html" title="cpp/language/implicit conversion">Implicit conversions</a> - <a href="explicit_cast.html" title="cpp/language/explicit cast">Explicit conversions</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="static_cast.html" title="cpp/language/static cast"><tt>static_cast</tt></a> - <a href="dynamic_cast.html" title="cpp/language/dynamic cast"><tt>dynamic_cast</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="const_cast.html" title="cpp/language/const cast"><tt>const_cast</tt></a> - <a href="reinterpret_cast.html" title="cpp/language/reinterpret cast"><tt>reinterpret_cast</tt></a></td></tr>
<tr class="t-nv-h2"><td colspan="5">Memory allocation</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="new.html" title="cpp/language/new"><code>new</code> expression</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="delete.html" title="cpp/language/delete"><code>delete</code> expression</a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"><a href="classes.html" title="cpp/language/classes">Classes</a></td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="class.html" title="cpp/language/class">Class declaration</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="initializer_list.html" title="cpp/language/constructor">Constructors</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="this.html" title="cpp/language/this"><code>this</code> pointer</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="access.html" title="cpp/language/access">Access specifiers</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="friend.html" title="cpp/language/friend"><code>friend</code> specifier</a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5">Class-specific function properties</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><strong class="selflink">Virtual function</strong></td></tr>
<tr class="t-nv"><td colspan="5"><a href="override.html" title="cpp/language/override"><code>override</code> specifier</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span>      </td></tr>
<tr class="t-nv"><td colspan="5"><a href="final.html" title="cpp/language/final"><code>final</code> specifier</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="explicit.html" title="cpp/language/explicit"><tt>explicit</tt></a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="static.html" title="cpp/language/static"><tt>static</tt></a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5">Special member functions</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="default_constructor.html" title="cpp/language/default constructor">Default constructor</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="copy_constructor.html" title="cpp/language/copy constructor">Copy constructor</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="move_constructor.html" title="cpp/language/move constructor">Move constructor</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="as_operator.html" title="cpp/language/as operator" class="mw-redirect">Copy assignment</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="move_operator.html" title="cpp/language/move operator" class="mw-redirect">Move assignment</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="destructor.html" title="cpp/language/destructor">Destructor</a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"><a href="templates.html" title="cpp/language/templates">Templates</a></td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="class_template.html" title="cpp/language/class template">Class template </a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="function_template.html" title="cpp/language/function template">Function template </a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="template_specialization.html" title="cpp/language/template specialization">Template specialization</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="parameter_pack.html" title="cpp/language/parameter pack">Parameter packs</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
</table></div></td></tr>
<tr class="t-nv-h1"><td colspan="5">Miscellaneous</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="asm.html" title="cpp/language/asm">Inline assembly</a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"><a href="history.html" title="cpp/language/history">History of C++</a></td></tr>
</table></div></td></tr>
</table></div>
</div><div></div></div></div></div><div class="t-navbar-sep"> </div><div class="t-navbar-head"><a href="classes.html" title="cpp/language/classes"> Classes</a><div class="t-navbar-menu"><div><div style="display:inline-block">
<div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv-h2"><td colspan="5">General</td></tr>
<tr class="t-nv"><td colspan="5"><a href="classes.html" title="cpp/language/classes">Overview</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="class.html" title="cpp/language/class"><code>class</code>/<code>struct</code> types</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="union.html" title="cpp/language/union"><code>union</code> types</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="injected-class-name.html" title="cpp/language/injected-class-name">Injected-class-name</a></td></tr>
<tr class="t-nv-h2"><td colspan="5">Members</td></tr>
<tr class="t-nv"><td colspan="5"><a href="data_members.html" title="cpp/language/data members">Data members</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="static.html" title="cpp/language/static">Static members</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="this.html" title="cpp/language/this">The <code>this</code> pointer</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="nested_classes.html" title="cpp/language/nested types">Nested classes</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="member_template.html" title="cpp/language/member template">Member templates</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="bitfield.html" title="cpp/language/bit field">Bit-fields</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="using_declaration.html" title="cpp/language/using declaration"><code>using</code>-declarations</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="member_functions.html" title="cpp/language/member functions">Member functions</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="access.html" title="cpp/language/access">Member access specifiers</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="initializer_list.html" title="cpp/language/constructor">Constructors and member initializer lists</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="data_members.html#Member_initialization" title="cpp/language/data members">Default member initializer</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="friend.html" title="cpp/language/friend"><code>friend</code> specifier</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="explicit.html" title="cpp/language/explicit"><code>explicit</code> specifier</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="converting_constructor.html" title="cpp/language/converting constructor">Converting constructor</a></td></tr>
<tr class="t-nv-h2"><td colspan="5">Special member functions</td></tr>
<tr class="t-nv"><td colspan="5"><a href="default_constructor.html" title="cpp/language/default constructor">Default constructor</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="copy_constructor.html" title="cpp/language/copy constructor">Copy constructor</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="move_constructor.html" title="cpp/language/move constructor">Move constructor</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="as_operator.html" title="cpp/language/copy assignment">Copy assignment operator</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="move_operator.html" title="cpp/language/move assignment">Move assignment operator</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="destructor.html" title="cpp/language/destructor">Destructor</a></td></tr>
<tr class="t-nv-h2"><td colspan="5">Inheritance</td></tr>
<tr class="t-nv"><td colspan="5"><a href="derived_class.html" title="cpp/language/derived class">Base and derived classes</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="ebo.html" title="cpp/language/ebo">Empty base optimization (EBO)</a></td></tr>
<tr class="t-nv"><td colspan="5"><strong class="selflink">Virtual member functions</strong></td></tr>
<tr class="t-nv"><td colspan="5"><a href="abstract_class.html" title="cpp/language/abstract class">Pure virtual functions and abstract classes</a></td></tr>
<tr class="t-nv"><td colspan="5"><a href="override.html" title="cpp/language/override"><code>override</code> specifier</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><a href="final.html" title="cpp/language/final"><code>final</code> specifier</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
</table></div>
</div><div></div></div></div></div><div class="t-navbar-sep"> </div></div>
<p>The <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">virtual</span></span></span> specifier specifies that a non-static <a href="member_functions.html" title="cpp/language/member functions">member function</a> is <i>virtual</i> and supports dynamic dispatch. It may only appear in the <span class="t-spar">decl-specifier-seq</span> of the initial declaration of a non-static member function (i.e., when it is declared in the class definition).
</p>
<h3><span class="mw-headline" id="Explanation">Explanation</span></h3>
<p>Virtual functions are member functions whose behavior can be overridden in derived classes. As opposed to non-virtual functions, the overriding behavior is preserved even if there is no compile-time information about the actual type of the class. That is to say, if a derived class is handled using pointer or reference to the base class, a call to an overridden virtual function would invoke the behavior defined in the derived class. Such a function call is known as <i>virtual function call</i> or <i>virtual call</i>. Virtual function call is suppressed if the function is selected using <a href="lookup.html" title="cpp/language/lookup">qualified name lookup</a> (that is, if the function's name appears to the right of the scope resolution operator <code>::</code>).
</p>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
 
<span class="kw1">struct</span> Base
<span class="br0">{</span>
    <span class="kw1">virtual</span> <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span>
    <span class="br0">{</span>
        <a href="../io/cout.html"><span class="kw1763">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"base<span class="es1">\n</span>"</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">struct</span> Derived <span class="sy4">:</span> Base
<span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> override <span class="co1">// 'override' is optional</span>
    <span class="br0">{</span>
        <a href="../io/cout.html"><span class="kw1763">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"derived<span class="es1">\n</span>"</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    Base b<span class="sy4">;</span>
    Derived d<span class="sy4">;</span>
 
    <span class="co1">// virtual function call through reference</span>
    Base<span class="sy3">&amp;</span> br <span class="sy1">=</span> b<span class="sy4">;</span> <span class="co1">// the type of br is Base&amp;</span>
    Base<span class="sy3">&amp;</span> dr <span class="sy1">=</span> d<span class="sy4">;</span> <span class="co1">// the type of dr is Base&amp; as well</span>
    br.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// prints "base"</span>
    dr.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// prints "derived"</span>
 
    <span class="co1">// virtual function call through pointer</span>
    Base<span class="sy2">*</span> bp <span class="sy1">=</span> <span class="sy3">&amp;</span>b<span class="sy4">;</span> <span class="co1">// the type of bp is Base*</span>
    Base<span class="sy2">*</span> dp <span class="sy1">=</span> <span class="sy3">&amp;</span>d<span class="sy4">;</span> <span class="co1">// the type of dp is Base* as well</span>
    bp<span class="sy2">-</span><span class="sy1">&gt;</span>f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// prints "base"</span>
    dp<span class="sy2">-</span><span class="sy1">&gt;</span>f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// prints "derived"</span>
 
    <span class="co1">// non-virtual function call</span>
    br.<span class="me1">Base</span><span class="sy4">::</span><span class="me2">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// prints "base"</span>
    dr.<span class="me1">Base</span><span class="sy4">::</span><span class="me2">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// prints "base"</span>
<span class="br0">}</span></pre></div></div>
</div>
<h3><span class="mw-headline" id="In_detail">In detail</span></h3>
<p>If some member function <code>vf</code> is declared as <code>virtual</code> in a class <code>Base</code>, and some class <code>Derived</code>, which is derived, directly or indirectly, from <code>Base</code>, has a declaration for member function with the same 
</p>
<ul><li> name
</li><li> parameter type list (but not the return type)
</li><li> cv-qualifiers
</li><li> ref-qualifiers
</li></ul>
<p>Then this function in the class <code>Derived</code> is also <i>virtual</i> (whether or not the keyword <code>virtual</code> is used in its declaration) and <i>overrides</i> Base::vf (whether or not the word <code>override</code> is used in its declaration).
</p><p><code>Base::vf</code> does not need to be accessible or visible to be overridden. (<code>Base::vf</code> can be declared private, or <code>Base</code> can be inherited using private inheritance. Any members with the same name in a base class of <code>Derived</code> which inherits <code>Base</code> do not matter for override determination, even if they would hide <code>Base::vf</code> during name lookup.)
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">class</span> B
<span class="br0">{</span>
    <span class="kw1">virtual</span> <span class="kw4">void</span> do_f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// private member</span>
<span class="kw1">public</span><span class="sy4">:</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> do_f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span> <span class="co1">// public interface</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">struct</span> D <span class="sy4">:</span> <span class="kw1">public</span> B
<span class="br0">{</span>
    <span class="kw4">void</span> do_f<span class="br0">(</span><span class="br0">)</span> override<span class="sy4">;</span> <span class="co1">// overrides B::do_f</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    D d<span class="sy4">;</span>
    B<span class="sy2">*</span> bp <span class="sy1">=</span> <span class="sy3">&amp;</span>d<span class="sy4">;</span>
    bp<span class="sy2">-</span><span class="sy1">&gt;</span>f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// internally calls D::do_f();</span>
<span class="br0">}</span></pre></div></div>
<p>For every virtual function, there is the <i>final overrider</i>, which is executed when a virtual function call is made. A virtual member function <code>vf</code> of a base class <code>Base</code> is the final overrider unless the derived class declares or inherits (through multiple inheritance) another function that overrides <code>vf</code>.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> A <span class="br0">{</span> <span class="kw1">virtual</span> <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>     <span class="co1">// A::f is virtual</span>
<span class="kw1">struct</span> B <span class="sy4">:</span> A <span class="br0">{</span> <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>         <span class="co1">// B::f overrides A::f in B</span>
<span class="kw1">struct</span> C <span class="sy4">:</span> <span class="kw1">virtual</span> B <span class="br0">{</span> <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span> <span class="co1">// C::f overrides A::f in C</span>
 
<span class="kw1">struct</span> D <span class="sy4">:</span> <span class="kw1">virtual</span> B <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// D does not introduce an overrider, B::f is final in D</span>
 
<span class="kw1">struct</span> E <span class="sy4">:</span> C, D          <span class="co1">// E does not introduce an overrider, C::f is final in E</span>
<span class="br0">{</span>
    <span class="kw1">using</span> A<span class="sy4">::</span><span class="me2">f</span><span class="sy4">;</span> <span class="co1">// not a function declaration, just makes A::f visible to lookup</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    E e<span class="sy4">;</span>
    e.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>    <span class="co1">// virtual call calls C::f, the final overrider in e</span>
    e.<span class="me1">E</span><span class="sy4">::</span><span class="me2">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// non-virtual call calls A::f, which is visible in E</span>
<span class="br0">}</span></pre></div></div>
<p>If a function has more than one final overrider, the program is ill-formed:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> A
<span class="br0">{</span>
    <span class="kw1">virtual</span> <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">struct</span> VB1 <span class="sy4">:</span> <span class="kw1">virtual</span> A
<span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// overrides A::f</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">struct</span> VB2 <span class="sy4">:</span> <span class="kw1">virtual</span> A
<span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// overrides A::f</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="co1">// struct Error : VB1, VB2</span>
<span class="co1">// {</span>
<span class="co1">//     // Error: A::f has two final overriders in Error</span>
<span class="co1">// };</span>
 
<span class="kw1">struct</span> Okay <span class="sy4">:</span> VB1, VB2
<span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK: this is the final overrider for A::f</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">struct</span> VB1a <span class="sy4">:</span> <span class="kw1">virtual</span> A <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// does not declare an overrider</span>
 
<span class="kw1">struct</span> Da <span class="sy4">:</span> VB1a, VB2
<span class="br0">{</span>
    <span class="co1">// in Da, the final overrider of A::f is VB2::f</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p>A function with the same name but different parameter list does not override the base function of the same name, but <i>hides</i> it: when <a href="lookup.html" title="cpp/language/lookup">unqualified name lookup</a> examines the scope of the derived class, the lookup finds the declaration and does not examine the base class.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> B
<span class="br0">{</span>
    <span class="kw1">virtual</span> <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">struct</span> D <span class="sy4">:</span> B
<span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// D::f hides B::f (wrong parameter list)</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">struct</span> D2 <span class="sy4">:</span> D
<span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// D2::f overrides B::f (doesn't matter that it's not visible)</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    B b<span class="sy4">;</span>
    B<span class="sy3">&amp;</span> b_as_b <span class="sy1">=</span> b<span class="sy4">;</span>
 
    D d<span class="sy4">;</span>
    B<span class="sy3">&amp;</span> d_as_b <span class="sy1">=</span> d<span class="sy4">;</span>
    D<span class="sy3">&amp;</span> d_as_d <span class="sy1">=</span> d<span class="sy4">;</span>
 
    D2 d2<span class="sy4">;</span>
    B<span class="sy3">&amp;</span> d2_as_b <span class="sy1">=</span> d2<span class="sy4">;</span>
    D<span class="sy3">&amp;</span> d2_as_d <span class="sy1">=</span> d2<span class="sy4">;</span>
 
    b_as_b.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// calls B::f()</span>
    d_as_b.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// calls B::f()</span>
    d2_as_b.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// calls D2::f()</span>
 
    d_as_d.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// Error: lookup in D finds only f(int)</span>
    d2_as_d.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// Error: lookup in D finds only f(int)</span>
<span class="br0">}</span></pre></div></div>
 <table class="t-rev-begin">
<tr class="t-rev t-since-cxx11"><td>
<p>If a function is declared with the specifier <code>override</code>, but does not override a virtual function, the program is ill-formed:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> B
<span class="br0">{</span>
    <span class="kw1">virtual</span> <span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">struct</span> D <span class="sy4">:</span> B
<span class="br0">{</span>
    <span class="kw1">virtual</span> <span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> override<span class="sy4">;</span>  <span class="co1">// OK, D::f(int) overrides B::f(int)</span>
    <span class="kw1">virtual</span> <span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">long</span><span class="br0">)</span> override<span class="sy4">;</span> <span class="co1">// Error: f(long) does not override B::f(int)</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p>If a function is declared with the specifier <code>final</code>, and another function attempts to override it, the program is ill-formed:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> B
<span class="br0">{</span>
    <span class="kw1">virtual</span> <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> final<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">struct</span> D <span class="sy4">:</span> B
<span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span><span class="sy4">;</span> <span class="co1">// Error: D::f attempts to override final B::f</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td></tr>
</table>
<p>Non-member functions and static member functions cannot be virtual.
</p><p>Function templates cannot be declared <code>virtual</code>. This applies only to functions that are themselves templates - a regular member function of a class template can be declared virtual.
</p>
 <table class="t-rev-begin">
<tr class="t-rev t-since-cxx20"><td>
<p>Virtual functions (whether declared virtual or overriding one) cannot have any associated constraints.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> A
<span class="br0">{</span>
    <span class="kw1">virtual</span> <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> requires <span class="kw2">true</span><span class="sy4">;</span> <span class="co1">// Error: constrained virtual function</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p>A <a href="consteval.html" title="cpp/language/consteval"><code>consteval</code></a> virtual function must not override or be overidden by a non-<code>consteval</code> virtual function.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td></tr>
</table>
<p><a href="default_arguments.html" title="cpp/language/default arguments">Default arguments</a> for virtual functions are substituted at the compile time.
</p>
<h4><span class="mw-headline" id="Covariant_return_types">Covariant return types</span></h4>
<p>If the function <code>Derived::f</code> overrides a function <code>Base::f</code>, their return types must either be the same or be <i>covariant</i>. Two types are covariant if they satisfy all of the following requirements:
</p>
<ul><li> both types are pointers or references (lvalue or rvalue) to classes. Multi-level pointers or references are not allowed.
</li><li> the referenced/pointed-to class in the return type of <code>Base::f()</code> must be an unambiguous and accessible direct or indirect base class of the referenced/pointed-to class of the return type of <code>Derived::f()</code>.
</li><li> the return type of <code>Derived::f()</code> must be equally or less <a href="cv.html" title="cpp/language/cv"> cv-qualified</a> than the return type of <code>Base::f()</code>.
</li></ul>
<p>The class in the return type of <code>Derived::f</code> must be either <code>Derived</code> itself, or must be a <a href="incomplete_type.html" title="cpp/language/incomplete type" class="mw-redirect">complete type</a> at the point of declaration of <code>Derived::f</code>.
</p><p>When a virtual function call is made, the type returned by the final overrider is <a href="implicit_cast.html" title="cpp/language/implicit cast" class="mw-redirect">implicitly converted</a> to the return type of the overridden function that was called:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">class</span> B <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">struct</span> Base
<span class="br0">{</span>
    <span class="kw1">virtual</span> <span class="kw4">void</span> vf1<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">virtual</span> <span class="kw4">void</span> vf2<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">virtual</span> <span class="kw4">void</span> vf3<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">virtual</span> B<span class="sy2">*</span> vf4<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">virtual</span> B<span class="sy2">*</span> vf5<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">class</span> D <span class="sy4">:</span> <span class="kw1">private</span> B
<span class="br0">{</span>
    <span class="kw1">friend</span> <span class="kw1">struct</span> Derived<span class="sy4">;</span> <span class="co1">// in Derived, B is an accessible base of D</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">class</span> A<span class="sy4">;</span> <span class="co1">// forward-declared class is an incomplete type</span>
 
<span class="kw1">struct</span> Derived <span class="sy4">:</span> <span class="kw1">public</span> Base
<span class="br0">{</span>
    <span class="kw4">void</span> vf1<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>    <span class="co1">// virtual, overrides Base::vf1()</span>
    <span class="kw4">void</span> vf2<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// non-virtual, hides Base::vf2()</span>
<span class="co1">//  char vf3();    // Error: overrides Base::vf3, but has different</span>
                   <span class="co1">// and non-covariant return type</span>
    D<span class="sy2">*</span> vf4<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>      <span class="co1">// overrides Base::vf4() and has covariant return type</span>
<span class="co1">//  A* vf5();      // Error: A is incomplete type</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    Derived d<span class="sy4">;</span>
    Base<span class="sy3">&amp;</span> br <span class="sy1">=</span> d<span class="sy4">;</span>
    Derived<span class="sy3">&amp;</span> dr <span class="sy1">=</span> d<span class="sy4">;</span>
 
    br.<span class="me1">vf1</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// calls Derived::vf1()</span>
    br.<span class="me1">vf2</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// calls Base::vf2()</span>
<span class="co1">//  dr.vf2(); // Error: vf2(int) hides vf2()</span>
 
    B<span class="sy2">*</span> p <span class="sy1">=</span> br.<span class="me1">vf4</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// calls Derived::vf4() and converts the result to B*</span>
    D<span class="sy2">*</span> q <span class="sy1">=</span> dr.<span class="me1">vf4</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// calls Derived::vf4() and does not convert the result to B*</span>
<span class="br0">}</span></pre></div></div>
<h4><span class="mw-headline" id="Virtual_destructor">Virtual destructor</span></h4>
<p>Even though destructors are not inherited, if a base class declares its destructor <code>virtual</code>, the derived destructor always overrides it. This makes it possible to delete dynamically allocated objects of polymorphic type through pointers to base.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">class</span> Base
<span class="br0">{</span>
<span class="kw1">public</span><span class="sy4">:</span>
    <span class="kw1">virtual</span> ~Base<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="coMULTI">/* releases Base's resources */</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">class</span> Derived <span class="sy4">:</span> <span class="kw1">public</span> Base
<span class="br0">{</span>
    ~Derived<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="coMULTI">/* releases Derived's resources */</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    Base<span class="sy2">*</span> b <span class="sy1">=</span> new Derived<span class="sy4">;</span>
    delete b<span class="sy4">;</span> <span class="co1">// Makes a virtual function call to Base::~Base()</span>
              <span class="co1">// since it is virtual, it calls Derived::~Derived() which can</span>
              <span class="co1">// release resources of the derived class, and then calls</span>
              <span class="co1">// Base::~Base() following the usual order of destruction</span>
<span class="br0">}</span></pre></div></div>
<p>Moreover, if the destructor of the base class is not virtual, deleting a derived class object through a pointer to the base class is <i>undefined behavior</i> regardless of whether there are resources that would be leaked if the derived destructor is not invoked<span class="t-rev-inl t-since-cxx20"><span>, unless the selected deallocation function is a destroying <span class="t-lc"><a href="../memory/new/operator_delete.html" title="cpp/memory/new/operator delete">operator delete</a></span></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>.
</p><p>A useful guideline is that the destructor of any base class must be <a rel="nofollow" class="external text" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-dtor-virtual">public and virtual or protected and non-virtual</a>, whenever delete expressions are involved<span class="t-rev-inl t-since-cxx11"><span>, e.g. when implicitly used in <span class="t-lc"><a href="../memory/unique_ptr.html" title="cpp/memory/unique ptr">std::unique_ptr</a></span></span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>.
</p>
<h3><span class="mw-headline" id="During_construction_and_destruction">During construction and destruction</span></h3>
<p>When a virtual function is called directly or indirectly from a constructor or from a destructor (including during the construction or destruction of the class’s non-static data members, e.g. in a member <a href="initializer_list.html" title="cpp/language/initializer list" class="mw-redirect">initializer list</a>), and the object to which the call applies is the object under construction or destruction, the function called is the final overrider
in the constructor’s or destructor’s class and not one overriding it in a more-derived class. 
In other words, during construction or destruction, the more-derived classes do not exist.
</p><p>When constructing a complex class with multiple branches, within a constructor that belongs to one branch, polymorphism is restricted to that class and its bases: if it obtains a pointer or reference to a base subobject outside this subhierarchy, and attempts to invoke a virtual function call (e.g. using explicit member access), the behavior is undefined:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> V
<span class="br0">{</span>
    <span class="kw1">virtual</span> <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">virtual</span> <span class="kw4">void</span> g<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">struct</span> A <span class="sy4">:</span> <span class="kw1">virtual</span> V
<span class="br0">{</span>
    <span class="kw1">virtual</span> <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// A::f is the final overrider of V::f in A</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">struct</span> B <span class="sy4">:</span> <span class="kw1">virtual</span> V
<span class="br0">{</span>
    <span class="kw1">virtual</span> <span class="kw4">void</span> g<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// B::g is the final overrider of V::g in B</span>
    B<span class="br0">(</span>V<span class="sy2">*</span>, A<span class="sy2">*</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">struct</span> D <span class="sy4">:</span> A, B
<span class="br0">{</span>
    <span class="kw1">virtual</span> <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// D::f is the final overrider of V::f in D</span>
    <span class="kw1">virtual</span> <span class="kw4">void</span> g<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// D::g is the final overrider of V::g in D</span>
 
    <span class="co1">// note: A is initialized before B</span>
    D<span class="br0">(</span><span class="br0">)</span> <span class="sy4">:</span> B<span class="br0">(</span><span class="br0">(</span>A<span class="sy2">*</span><span class="br0">)</span> this, this<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="co1">// the constructor of B, called from the constructor of D </span>
B<span class="sy4">::</span><span class="me2">B</span><span class="br0">(</span>V<span class="sy2">*</span> v, A<span class="sy2">*</span> a<span class="br0">)</span>
<span class="br0">{</span>
    f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// virtual call to V::f (although D has the final overrider, D doesn't exist)</span>
    g<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// virtual call to B::g, which is the final overrider in B </span>
 
    v<span class="sy2">-</span><span class="sy1">&gt;</span>g<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// v's type V is base of B, virtual call calls B::g as before</span>
 
    a<span class="sy2">-</span><span class="sy1">&gt;</span>f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// a’s type A is not a base of B. it belongs to a different branch of the</span>
            <span class="co1">// hierarchy. Attempting a virtual call through that branch causes</span>
            <span class="co1">// undefined behavior even though A was already fully constructed in this</span>
            <span class="co1">// case (it was constructed before B since it appears before B in the list</span>
            <span class="co1">// of the bases of D). In practice, the virtual call to A::f will be</span>
            <span class="co1">// attempted using B's virtual member function table, since that's what</span>
            <span class="co1">// is active during B's construction)</span>
<span class="br0">}</span></pre></div></div>
<h3><span class="mw-headline" id="Defect_reports">Defect reports</span></h3>
<p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.
</p>
<table class="dsctable" style="font-size:0.8em">
<tr>
<th> DR
</th>
<th> Applied to
</th>
<th> Behavior as published
</th>
<th> Correct behavior
</th></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/258.html">CWG 258</a>
</td>
<td> C++98
</td>
<td> a non-const member function of a derived class might become<br>virtual because of a const virtual member function of its base
</td>
<td> virtuality also require cv-<br>qualifications to be the same
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/477.html">CWG 477</a>
</td>
<td> C++98
</td>
<td> a friend declaration could contain the <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">virtual</span></span></span> specifier
</td>
<td> not allowed
</td></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1516.html">CWG 1516</a>
</td>
<td> C++98
</td>
<td> the definition of the terms "virtual function call"<br>and "virtual call" were not provided
</td>
<td> provided
</td></tr></table>
<h3><span class="mw-headline" id="See_also">See also</span></h3>
<table class="t-dsc-begin">

<tr class="t-dsc">
<td colspan="2"> <a href="derived_class.html" title="cpp/language/derived class">derived classes and modes of inheritance</a>
</td></tr>


<tr class="t-dsc">
<td>  <a href="override.html" title="cpp/language/override"> <code>override</code> specifier</a><span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td>
<td>  explicitly declares that a method overrides another method </td></tr>

<tr class="t-dsc">
<td>  <a href="final.html" title="cpp/language/final"> <code>final</code> specifier</a><span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td>
<td>  declares that a method cannot be overridden </td></tr>
</table>

<!-- 
NewPP limit report
Preprocessor visited node count: 3103/1000000
Preprocessor generated node count: 8174/1000000
Post‐expand include size: 142559/2097152 bytes
Template argument size: 22970/2097152 bytes
Highest expansion depth: 16/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:4061-0!*!0!!en!*!* and timestamp 20230701003604 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/virtual&amp;oldid=139982">https://en.cppreference.com/mwiki/index.php?title=cpp/language/virtual&amp;oldid=139982</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        <div id="cpp-footer-base" class="noprint">
            <div id="footer">
                        <div id="cpp-navigation">
            <h5>Navigation</h5>
            <ul><li><a href="https://en.cppreference.com/w/cpp/language/virtual">Online version</a></li><li>Offline version retrieved 2023-08-10 21:32.</li></ul></div>
                        <ul id="footer-info">
                                    <li id="footer-info-lastmod"> This page was last modified on 1 June 2022, at 02:57.</li>
                                    <li id="footer-info-viewcount">This page has been accessed 686,730 times.</li>
                            </ul>
                    </div>
        </div>
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="../../../common/skin_scripts.js"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.ColiruCompiler","ext.gadget.MathJax"], null, true);
}</script>
<script src="../../../common/site_scripts.js"></script>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-2828341-1']);
_gaq.push(['_setDomainName', 'cppreference.com']);
_gaq.push(['_trackPageview']);
</script><!-- Served in 2.158 secs. -->
	</body>
<!-- Cached 20230701003604 -->
</html>